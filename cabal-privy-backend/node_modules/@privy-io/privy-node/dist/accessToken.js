"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.jwtKeyFromApiSecret = exports.createAccessTokenClaims = exports.signAccessToken = void 0;
const crypto_1 = __importDefault(require("crypto"));
const jose_1 = require("jose");
const tweetnacl_1 = __importDefault(require("tweetnacl"));
const secondsSinceEpoch = () => {
    return Math.floor(new Date().getTime() / 1000);
};
/**
 * Signs access token claims with the provided signing key, returning a JWT string.
 */
const signAccessToken = (signingKey, claims) => {
    return new jose_1.SignJWT(claims).setProtectedHeader({ alg: 'EdDSA', typ: 'JWT' }).sign(signingKey);
};
exports.signAccessToken = signAccessToken;
/**
 * Returns access token claims for the given data requester.
 */
const createAccessTokenClaims = (apiKey, requesterId) => {
    const TEN_MINUTES_IN_SECONDS = 600;
    const issuedAt = secondsSinceEpoch();
    const expiration = issuedAt + TEN_MINUTES_IN_SECONDS;
    return {
        aid: '',
        aud: 'api.privy.io',
        exp: expiration,
        iat: issuedAt,
        iss: apiKey,
        // TODO: Roles are computed by the backend, but the token schema currently still requires this field to be an array.
        rls: [],
        sub: requesterId,
    };
};
exports.createAccessTokenClaims = createAccessTokenClaims;
/**
 * Returns the JWT signing key generated deterministically from the API secret.
 */
const jwtKeyFromApiSecret = (apiSecret) => {
    // Decode from URL-safe base64.
    const apiSecretBuffer = Buffer.from(apiSecret, 'base64');
    // Generate the signing key pair deterministicaly from the secret.
    const keyPair = tweetnacl_1.default.sign.keyPair.fromSeed(apiSecretBuffer);
    // Convert raw Ed25519 key buffers into Node crypto KeyObjects.
    const privateKeyJwk = {
        crv: 'Ed25519',
        d: Buffer.from(keyPair.secretKey.slice(0, 32)).toString('base64'),
        x: Buffer.from(keyPair.publicKey).toString('base64'),
        kty: 'OKP',
    };
    return crypto_1.default.createPrivateKey({
        key: privateKeyJwk,
        format: 'jwk',
    });
};
exports.jwtKeyFromApiSecret = jwtKeyFromApiSecret;
//# sourceMappingURL=accessToken.js.map