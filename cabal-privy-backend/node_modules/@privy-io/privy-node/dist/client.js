"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PrivyClient = void 0;
const form_data_1 = __importDefault(require("form-data"));
const crypto_1 = require("@privy-io/crypto");
const http_1 = require("./http");
const constants_1 = require("./constants");
const paths_1 = require("./paths");
const utils_1 = require("./utils");
const fieldInstance_1 = require("./fieldInstance");
const errors_1 = require("./errors");
const encoding_1 = __importStar(require("./encoding"));
const hash_1 = require("./hash");
const config_1 = require("./config");
const handlebars_1 = __importDefault(require("handlebars"));
// At the moment, there is only one version of
// Privy's crypto system, so this can be hardcoded.
// Once there are > 1 versions, this will need to be
// dynamic, at least for decryption.
const x0 = (0, crypto_1.CryptoEngine)(crypto_1.CryptoVersion.x0);
/**
 * The Privy client performs operations against the Privy API.
 *
 * ```typescript
 * import {PrivyClient} from '@privy-io/privy-node';
 * ```
 */
class PrivyClient extends config_1.PrivyConfig {
    /**
     * Creates a new Privy client.
     * @param apiKey Privy API key.
     * @param apiSecret Privy API secret.
     * @param options Initialization options.
     */
    constructor(apiKey, apiSecret, options = {}) {
        const apiURL = options.apiURL || constants_1.PRIVY_API_URL;
        const kmsURL = options.kmsURL || constants_1.PRIVY_KMS_URL;
        const timeout = options.timeout || constants_1.DEFAULT_TIMEOUT_MS;
        // Initialize base class.
        super(apiKey, apiSecret, {
            apiURL,
            kmsURL,
            timeout,
            customSigningFn: options.customSigningFn,
        });
        const authenticate = () => super.createAccessToken(constants_1.REQUESTER_ID_ADMIN);
        this.api = new http_1.Http(authenticate, {
            baseURL: apiURL,
            timeout: timeout,
        });
        this.kms = new http_1.Http(authenticate, {
            baseURL: kmsURL,
            timeout: timeout,
        });
    }
    async get(userId, fields) {
        const path = (0, paths_1.userDataPath)(userId, (0, utils_1.wrap)(fields));
        try {
            const response = await this.api.get(path);
            const decrypted = await this.decrypt(userId, response.data.data);
            return typeof fields === 'string' ? decrypted[0] : decrypted;
        }
        catch (error) {
            throw (0, errors_1.formatPrivyError)(error);
        }
    }
    /**
     * Get a batch of admin-accessible user data from the Privy API, indexed by user ID.
     *
     * @param fields: String field name or an array of string field names.
     * @param options Optional object containing batch request configuration.
     * @param options.cursor Optional user ID to start from. Returned by previous call to `getBatch`.
     * @param options.limit Optional maximum number of users to return.
     */
    async getBatch(fields, options = {}) {
        const path = (0, paths_1.batchUserDataPath)((0, utils_1.wrap)(fields), options);
        try {
            const response = await this.api.get(path);
            const decrypted = await this.decryptBatch((0, utils_1.wrap)(fields), response.data);
            return { next_cursor_id: response.data.next_cursor_id, users: decrypted };
        }
        catch (error) {
            throw (0, errors_1.formatPrivyError)(error);
        }
    }
    async put(userId, fields, value) {
        const data = typeof fields === 'string' ? [{ field: fields, value: value }] : fields;
        const path = (0, paths_1.userDataPath)(userId);
        const encryptedData = await this.encrypt(userId, data);
        try {
            const response = await this.api.post(path, { data: encryptedData });
            const result = response.data.data.map((field, index) => {
                const plaintext = encoding_1.default.toBuffer(data[index].value, 'utf8');
                return new fieldInstance_1.FieldInstance(field, plaintext, 'text/plain');
            });
            return typeof fields === 'string' ? result[0] : result;
        }
        catch (error) {
            throw (0, errors_1.formatPrivyError)(error);
        }
    }
    /**
     * Download a file stored under a field.
     *
     * ```typescript
     * const avatar = await client.getFile("0x123", "avatar");
     * download(avatar);
     *
     * function download(field: FieldInstance) {
     *   const data = window.URL.createObjectURL(field.blob());
     *
     *   // Lookup extension by mime type (included on blob)
     *   const ext = getExtensionFromMIMEType(blob.type);
     *   const filename = `${field.integrity_hash}.${ext}`;
     *
     *   // Create a link pointing to the ObjectURL containing the blob.
     *   const link = document.createElement("a");
     *   link.style = "display: none;";
     *   link.href = data;
     *   link.download = filename;
     *   link.click();
     *
     *   // Cleanup
     *   window.URL.revokeObjectURL(data);
     *   link.remove();
     * }
     * ```
     *
     * @param userId The id of the user this file belongs to.
     * @param field The field the file is stored under.
     * @returns A {@link FieldInstance} if the file exists, or `null` otherwise.
     */
    async getFile(userId, field) {
        const path = (0, paths_1.userDataPath)(userId, [field]);
        try {
            const response = await this.api.get(path);
            const field = response.data.data[0];
            if (field === null) {
                return null;
            }
            if (field.object_type !== 'file') {
                throw new errors_1.PrivyClientError(`${field.field_id} is not a file`);
            }
            const downloadResponse = await this.api.get((0, paths_1.fileDownloadsPath)(field.user_id, field.field_id, field.value), {
                responseType: 'arraybuffer',
            });
            const ciphertext = new Uint8Array(downloadResponse.data);
            const contentType = downloadResponse.headers['privy-file-content-type'];
            const plaintext = await this.decryptFile(userId, field, ciphertext);
            return new fieldInstance_1.FieldInstance(field, plaintext, contentType);
        }
        catch (error) {
            throw (0, errors_1.formatPrivyError)(error);
        }
    }
    /**
     * Upload a file for a given field.
     *
     * ```typescript
     * const onUpdateAvatar = async (avatar: File) => {
     *   try {
     *     await client.putFile("0x123", "avatar", avatar);
     *   } catch (error) {
     *     console.log(error);
     *   }
     * };
     * ```
     *
     * @param userId The id of the user this file belongs to.
     * @param field The field to store the file in.
     * @param blob The plaintext contents of the file in a Blob.
     * @returns {@link FieldInstance} for the uploaded file.
     */
    async putFile(userId, field, plaintext, contentType) {
        try {
            const { ciphertext, contentMD5, wrapperKeyId, integrityHash } = await this.encryptFile(userId, field, plaintext);
            const formData = new form_data_1.default();
            formData.append('content_type', contentType);
            formData.append('file_id', integrityHash);
            formData.append('content_md5', contentMD5);
            formData.append('wrapper_key_id', wrapperKeyId);
            formData.append('file', (0, encoding_1.wrapAsBuffer)(ciphertext), {
                contentType: 'application/octet-stream',
                // A non-empty filename is required in order for this multipart field to be recognized as a file.
                // This value is ignored by the server.
                filename: 'file',
            });
            const uploadResponse = await this.api.post((0, paths_1.fileUploadsPath)(userId, field), formData, {
                headers: formData.getHeaders(),
            });
            const file = uploadResponse.data;
            const response = await this.api.post((0, paths_1.userDataPath)(userId), {
                data: [
                    {
                        field_id: field,
                        object_type: 'file',
                        value: file.id,
                        integrity_hash: integrityHash,
                    },
                ],
            });
            return new fieldInstance_1.FieldInstance(response.data.data[0], plaintext, contentType);
        }
        catch (error) {
            throw (0, errors_1.formatPrivyError)(error);
        }
    }
    /**
     * Lookup a field instance by its integrity hash. This method can be used to verify data in addition to fetching it from Privy. For example, this method will:
     *
     * 1. Lookup data by integrity hash
     * 2. Return the field instance if it exists
     * 3. Re-compute the integrity hash client side. If it is NOT the same as the `integrityHash` argument, this method will throw an error.
     *
     * ```typescript
     * const ssn = await client.put("0x123", "ssn", "123-45-6789");
     * const ssnIntegrityHash = ssn.integrity_hash;
     *
     * // later on...
     * const ssn = await client.getByIntegrityHash(ssnIntegrityHash);
     * ```
     *
     * @param integrityHash Hash used for content addressing.
     * @returns The corresponding {@link FieldInstance} if it exists, or `null` otherwise.
     */
    async getByIntegrityHash(integrityHash) {
        try {
            const path = (0, paths_1.integrityHashPath)(integrityHash);
            const response = await this.api.get(path);
            const field = response.data.data[0];
            if (field === null) {
                return null;
            }
            if (field.object_type === 'string') {
                const ciphertext = encoding_1.default.toBuffer(field.value, 'base64');
                const plaintext = await this.decryptAndVerify(field, ciphertext, integrityHash);
                return new fieldInstance_1.FieldInstance(field, plaintext, 'text/plain');
            }
            else {
                const downloadResponse = await this.api.get((0, paths_1.fileDownloadsPath)(field.user_id, field.field_id, field.value), {
                    responseType: 'arraybuffer',
                });
                const ciphertext = new Uint8Array(downloadResponse.data);
                const contentType = downloadResponse.headers['privy-file-content-type'];
                const plaintext = await this.decryptAndVerify(field, ciphertext, integrityHash);
                return new fieldInstance_1.FieldInstance(field, plaintext, contentType);
            }
        }
        catch (error) {
            throw (0, errors_1.formatPrivyError)(error);
        }
    }
    async encrypt(userId, data) {
        const wrapperKeys = await this.getWrapperKeys(userId, data.map(({ field }) => field), x0.WRAPPER_KEY_ALGORITHM);
        const encryptionPromises = data.map(async ({ field, value }, i) => {
            const wrapperKey = wrapperKeys[i];
            const privyEncryption = new x0.Encryption(encoding_1.default.toBuffer(value, 'utf8'), {
                wrapperKey: wrapperKey.publicKey,
                wrapperKeyId: wrapperKey.id,
            });
            const encryptedResult = await privyEncryption.encrypt();
            return {
                field_id: field,
                object_type: 'string',
                value: encoding_1.default.toString(encryptedResult.ciphertext(), 'base64'),
                wrapper_key_id: encoding_1.default.toString(encryptedResult.wrapperKeyId(), 'utf8'),
                integrity_hash: encoding_1.default.toString(encryptedResult.commitmentId(), 'hex'),
            };
        });
        return Promise.all(encryptionPromises);
    }
    async decrypt(userId, data) {
        const dataWithIndex = data.map((field, index) => ({ index, field }));
        const nullFieldsWithIndex = dataWithIndex.filter(({ field }) => {
            return field === null;
        });
        const stringFieldsWithIndex = dataWithIndex.filter(({ field }) => {
            return field !== null && field.object_type === 'string';
        });
        const fileFieldsWithIndex = dataWithIndex.filter(({ field }) => {
            return field !== null && field.object_type === 'file';
        });
        const fieldsToDecrypt = stringFieldsWithIndex.map(({ field, index }) => ({
            field,
            index,
            decryption: new x0.Decryption(encoding_1.default.toBuffer(field.value, 'base64')),
        }));
        // Prepare and decrypt the data keys
        const keysToDecrypt = fieldsToDecrypt.map(({ field, decryption }) => ({
            field_id: field.field_id,
            wrapper_key_id: encoding_1.default.toString(decryption.wrapperKeyId(), 'utf8'),
            encrypted_key: encoding_1.default.toString(decryption.encryptedDataKey(), 'base64'),
        }));
        const decryptedKeys = await this.decryptKeys({ user_id: userId, data: keysToDecrypt });
        // Using the data keys from previous step, decrypt all fields in need of decryption
        const decryptedStringFields = await Promise.all(fieldsToDecrypt.map(async ({ index, field, decryption }, i) => {
            const dataKey = decryptedKeys[i];
            const result = await decryption.decrypt(dataKey);
            return { index, field, plaintext: result.plaintext() };
        }));
        // Prepare the result of this function
        const results = new Array(data.length);
        // Maintaining order, populate the result with the (decrypted) string field values
        for (const { index, field, plaintext } of decryptedStringFields) {
            results[index] = new fieldInstance_1.FieldInstance(field, plaintext, 'text/plain');
        }
        // Maintaining order, populate the result with the file field values
        for (const { index, field } of fileFieldsWithIndex) {
            results[index] = new fieldInstance_1.FieldInstance(field, encoding_1.default.toBuffer(field.value, 'utf8'), 'text/plain');
        }
        // Maintaining order, populate the result with null fields
        for (const { index } of nullFieldsWithIndex) {
            results[index] = null;
        }
        return results;
    }
    async encryptFile(userId, field, plaintext) {
        const [wrapperKey] = await this.getWrapperKeys(userId, [field], x0.WRAPPER_KEY_ALGORITHM);
        const encryption = new x0.Encryption(plaintext, {
            wrapperKey: wrapperKey.publicKey,
            wrapperKeyId: wrapperKey.id,
        });
        const result = await encryption.encrypt();
        const ciphertext = result.ciphertext();
        const contentMD5 = (0, hash_1.md5)(ciphertext);
        const wrapperKeyId = encoding_1.default.toString(result.wrapperKeyId(), 'utf8');
        const integrityHash = encoding_1.default.toString(result.commitmentId(), 'hex');
        return {
            ciphertext,
            contentMD5,
            wrapperKeyId,
            integrityHash,
        };
    }
    async decryptFile(userId, field, uint8Array) {
        const decryption = new x0.Decryption(uint8Array);
        // Prepare and decrypt the data keys
        const keyToDecrypt = {
            field_id: field.field_id,
            wrapper_key_id: encoding_1.default.toString(decryption.wrapperKeyId(), 'utf8'),
            encrypted_key: encoding_1.default.toString(decryption.encryptedDataKey(), 'base64'),
        };
        const [dataKey] = await this.decryptKeys({ user_id: userId, data: [keyToDecrypt] });
        const result = await decryption.decrypt(dataKey);
        return result.plaintext();
    }
    async decryptAndVerify(field, ciphertext, integrityHash) {
        const decryption = new x0.Decryption(ciphertext);
        const keyToDecrypt = {
            field_id: field.field_id,
            wrapper_key_id: encoding_1.default.toString(decryption.wrapperKeyId(), 'utf8'),
            encrypted_key: encoding_1.default.toString(decryption.encryptedDataKey(), 'base64'),
        };
        const [dataKey] = await this.decryptKeys({ user_id: field.user_id, data: [keyToDecrypt] });
        const result = await decryption.decrypt(dataKey);
        if (!decryption.verify(result, encoding_1.default.toBuffer(integrityHash, 'hex'))) {
            throw new errors_1.PrivyClientError(`Data integrity check failed for field ${field.field_id} using hash ${integrityHash}`);
        }
        return result.plaintext();
    }
    async getWrapperKeys(userId, fields, algorithm) {
        if (fields.length === 0) {
            return [];
        }
        const path = (0, paths_1.wrapperKeyPath)(userId);
        const body = {
            algorithm,
            data: fields.map((field_id) => ({ field_id })),
        };
        const response = await this.kms.post(path, body);
        return response.data.data.map(({ id, public_key, algorithm }) => ({
            id: encoding_1.default.toBuffer(id, 'utf8'),
            publicKey: encoding_1.default.toBuffer(public_key, 'base64'),
            algorithm,
        }));
    }
    async decryptKeys(request) {
        if (request.data.length === 0) {
            return [];
        }
        const path = (0, paths_1.dataKeyPath)(request.user_id);
        const response = await this.kms.post(path, request);
        return response.data.data.map(({ key }) => encoding_1.default.toBuffer(key, 'base64'));
    }
    /**
     * Calls the KMS to decrypt the given data keys.
     * @param request The DataKeyBatchRequest to send to the KMS.
     * @returns 2-D Array of decrypted batch keys ordered by the same ordering of user, field as the
     * request, mapping to the decrypted key if it exists or `null` otherwise.
     */
    async decryptBatchKeys(request) {
        if (request.users.length === 0) {
            return new Array();
        }
        const path = (0, paths_1.batchDataKeyPath)();
        const response = await this.kms.post(path, request);
        const keyToBuffer = (value) => value.key === null ? null : encoding_1.default.toBuffer(value.key, 'base64');
        return response.data.users.map((userResponse) => userResponse.data.map(keyToBuffer));
    }
    /**
     * Decrypts the given encrypted batch data response and returns an array of UserFieldInstances in the
     * same order as the response.
     * @param fieldIDs The field IDs of the fields to decrypt.
     * @param batchDataResponse The response from the API with encrypted data.
     * @returns Array of UserFieldInstances in the same order as the response.
     */
    async decryptBatch(fieldIDs, batchDataResponse) {
        if (batchDataResponse.users.length === 0) {
            return [];
        }
        // Check that only string fields are requested. We don't handle files here.
        // Create decryption instances.
        const decryptionInstances = batchDataResponse.users.map((user) => {
            const fieldDecryptions = fieldIDs.map((_, fieldIdx) => {
                const field = user.data[fieldIdx];
                // Check that only non-files are attempted to be decrypted.
                if (field !== null && field.object_type === 'file') {
                    throw new errors_1.PrivyClientError('Batch decryption of files is not supported');
                }
                return field === null ? null : new x0.Decryption(encoding_1.default.toBuffer(field.value, 'base64'));
            });
            return fieldDecryptions;
        });
        // Get data keys.
        const dataKeyRequests = batchDataResponse.users.map((user, userIdx) => {
            const dataKeyRequests = fieldIDs.map((fieldID, fieldIdx) => {
                const decryption = decryptionInstances[userIdx][fieldIdx];
                return {
                    field_id: fieldID,
                    wrapper_key_id: decryption === null ? null : encoding_1.default.toString(decryption.wrapperKeyId(), 'utf8'),
                    encrypted_key: decryption === null
                        ? null
                        : encoding_1.default.toString(decryption.encryptedDataKey(), 'base64'),
                };
            });
            return { user_id: user.user_id, data: dataKeyRequests };
        });
        const decryptedKeys = await this.decryptBatchKeys({
            users: dataKeyRequests,
        });
        // Build decrypted field matrix.
        const decryptedFields = await Promise.all(batchDataResponse.users.map(async (_, userIdx) => {
            return await Promise.all(fieldIDs.map(async (_, fieldIdx) => {
                const dataKey = decryptedKeys[userIdx][fieldIdx];
                if (dataKey === null) {
                    return null;
                }
                else {
                    const decryption = decryptionInstances[userIdx][fieldIdx];
                    if (decryption === null) {
                        return null;
                    }
                    else {
                        const result = await decryption.decrypt(dataKey);
                        return result.plaintext();
                    }
                }
            }));
        }));
        // Collect results into userFieldInstances.
        const userIDs = batchDataResponse.users.map((user) => user.user_id);
        var userFieldInstances = new Array();
        userFieldInstances = userIDs.map((userID, userIdx) => {
            const fields = batchDataResponse.users[userIdx].data;
            const plaintext = decryptedFields[userIdx];
            const fieldInstances = fieldIDs.map((_, fieldIdx) => {
                if (fields[fieldIdx] === null || plaintext[fieldIdx] === null) {
                    return null;
                }
                else {
                    return new fieldInstance_1.FieldInstance(fields[fieldIdx], plaintext[fieldIdx], 'text/plain');
                }
            });
            return { user_id: userID, data: fieldInstances };
        });
        return userFieldInstances;
    }
    /**
     * Sends an email to a given user ID with the subject and HTML specified.
     *
     * Optionally, if you would like to incorporate user data into the email, you
     * may do so using the {@link https://handlebarsjs.com/ Handlebars} templating
     * format. Embed the field IDs corresponding to desired values into the HTML
     * content and update the fields param to include those fields.
     *
     * For example, if you include `fields=["username"]`, you can then use this in
     * your htmlContent like so: `htmlContent="Hello {{username}}, ..."`
     *
     * @param userId User ID
     * @param subject Subject of the email
     * @param htmlContent HTML content to send. If any handlebars content is included,
     *     it will be replaced using the fields provided before sending.
     * @param fields Single field ID or an array of field IDs to dynamically
     *     include in the email using Handlebars. Files, such as images, are not
     *     yet supported.
     *
     * @precondition In order for `sendEmail` to work, a valid destination email
     *     must already be stored for the input user `userId` in a field with the
     *     field ID `email`.
     */
    async sendEmail(userId, subject, htmlContent, fields) {
        try {
            // Fetch requested fields
            const fieldIds = ['email', ...(0, utils_1.wrap)(fields || []).filter((f) => f)];
            const path = (0, paths_1.userDataPath)(userId, fieldIds);
            const response = await this.api.get(path);
            const decrypted = await this.decrypt(userId, response.data.data);
            const indexedUserDataInput = {};
            for (const item of decrypted) {
                if (!item)
                    continue;
                indexedUserDataInput[item.field_id] = item.text();
            }
            // Apply the fields to the HTML using Handlebars. If the content has no
            // Handlebars, this is a no-op.
            const template = handlebars_1.default.compile(htmlContent);
            const templatedContent = template(indexedUserDataInput);
            // Make the API call to send
            const sendPath = `/actions/send_email`;
            await this.api.post(sendPath, {
                to_email: indexedUserDataInput['email'],
                subject: subject,
                html_content: templatedContent,
            }, undefined);
        }
        catch (error) {
            const errorType = error?.type || error?.statusText || error?.status || 'Unknown error';
            throw new errors_1.PrivyClientError(`${errorType}: email send failed for user ${userId}`);
        }
    }
}
exports.PrivyClient = PrivyClient;
//# sourceMappingURL=client.js.map