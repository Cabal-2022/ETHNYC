"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PrivyConfig = void 0;
const crypto_1 = __importDefault(require("crypto"));
const accessToken_1 = require("./accessToken");
const errors_1 = require("./errors");
const encoding_1 = require("./encoding");
const utils_1 = require("./utils");
const crypto_2 = require("@privy-io/crypto");
const http_1 = require("./http");
// At the moment, there is only one version of
// Privy's crypto system, so this can be hardcoded.
// Once there are > 1 versions, this will need to be
// dynamic, at least for decryption.
const x0 = (0, crypto_2.CryptoEngine)(crypto_2.CryptoVersion.x0);
// Endpoint routes.
const aliasPath = (userId) => `/users/${userId}/aliases`;
const deleteAliasPath = (userId, hashedAlias) => `/users/${userId}/aliases/${hashedAlias}`;
const aliasWrapperKeyPath = () => `/key_manager/alias_wrapper_keys`;
const aliasKeyPath = () => `/key_manager/alias_keys`;
const fieldsPath = () => '/fields';
const fieldPath = (fieldId) => `/fields/${fieldId}`;
const rolesPath = () => '/roles';
const rolePath = (roleId) => `/roles/${roleId}`;
const accessGroupsPath = () => '/access_groups';
const accessGroupPath = (accessGroupId) => `/access_groups/${accessGroupId}`;
const userPermissionsPath = (userId, fieldIds) => {
    if (Array.isArray(fieldIds)) {
        return `/users/${userId}/permissions?field_ids=${fieldIds.join(',')}`;
    }
    else {
        return `/users/${userId}/permissions`;
    }
};
const requesterRolesPath = (requesterId) => `/requesters/${requesterId}/roles`;
const roleRequestersPath = (roleId) => `/roles/${roleId}/requesters`;
const roleRequesterPath = (roleId, requesterId) => `/roles/${roleId}/requesters/${requesterId}`;
const createApiSecretSigningFn = (apiSecret) => {
    const jwtKey = (0, accessToken_1.jwtKeyFromApiSecret)(apiSecret);
    return (claims) => (0, accessToken_1.signAccessToken)(jwtKey, claims);
};
class PrivyConfig {
    /**
     * @internal
     */
    constructor(apiKey, apiSecret, config) {
        this._apiKey = apiKey;
        // Store the Privy KMS route.
        this._kmsRoute = config.kmsURL;
        // Use custom signing key if provided, otherwise generate it from the API secret.
        this._signingFn = config.customSigningFn ?? createApiSecretSigningFn(apiSecret);
        // Initialize the Axios HTTP client.
        this._axiosInstance = new http_1.Http(undefined, {
            baseURL: config.apiURL,
            timeout: config.timeout,
            auth: {
                username: apiKey,
                password: apiSecret,
            },
        });
    }
    /**
     * Request alias wrapper keys from the Privy KMS.
     * @internal
     */
    async _getAliasWrapperKey(algorithm) {
        const path = aliasWrapperKeyPath();
        const body = {
            algorithm,
        };
        const response = await this._axiosInstance.post(path, body, {
            baseURL: this._kmsRoute,
        });
        return {
            id: Buffer.from(response.data.id, 'utf8'),
            publicKey: Buffer.from(response.data.public_key, 'base64'),
            algorithm: response.data.algorithm,
        };
    }
    /**
     * Request alias keys from the Privy KMS
     * @internal
     */
    async _getAliasKeys(keys) {
        if (keys.length === 0) {
            return [];
        }
        const path = aliasKeyPath();
        const requestBody = {
            data: keys.map((key) => ({
                encrypted_key: (0, encoding_1.wrapAsBuffer)(key.encryptedKey).toString('base64'),
                alias_wrapper_key_id: (0, encoding_1.wrapAsBuffer)(key.wrapperKeyId).toString('utf8'),
            })),
        };
        const response = await this._axiosInstance.post(path, requestBody, {
            baseURL: this._kmsRoute,
        });
        return response.data.data.map(({ key }) => Buffer.from(key, 'base64'));
    }
    /**
     * @internal
     */
    async _decryptAliases(encAliasResponse) {
        if (encAliasResponse.encrypted_aliases.length === 0) {
            return { primary_user_id: encAliasResponse.primary_user_id, aliases: [] };
        }
        // For each alias, create privyDecryption instance.
        const aliasDecryption = encAliasResponse.encrypted_aliases.map((encAlias) => new x0.Decryption(Buffer.from(encAlias.ciphertext, 'base64')));
        // Get alias keys.
        const keys = aliasDecryption.map((decryption) => ({
            wrapperKeyId: decryption.wrapperKeyId(),
            encryptedKey: decryption.encryptedDataKey(),
        }));
        const aliasKeys = await this._getAliasKeys(keys);
        // Decrypt aliases.
        const aliases = await Promise.all((0, utils_1.mapPairs)(aliasKeys, aliasDecryption, async (aliasKey, privyDecryption) => {
            const decryptedResult = await privyDecryption.decrypt(aliasKey);
            return Buffer.from(decryptedResult.plaintext()).toString('utf8');
        }));
        return { primary_user_id: encAliasResponse.primary_user_id, aliases: aliases };
    }
    /**
     * Links a new user id alias to an pre-existing user id.
     * @param userId A user id for which data already exists.
     * @param alias A new user id to be linked to the pre-existing user id.
     * No data should previously exist for this new user id.
     * @returns AliasBundle containing the id's of all users that are linked together.
     */
    async link(userId, alias) {
        try {
            // Get wrapper key for alias.
            const wrapperKey = await this._getAliasWrapperKey(x0.WRAPPER_KEY_ALGORITHM);
            const privyEncryption = new x0.Encryption(Buffer.from(alias, 'utf8'), {
                wrapperKey: wrapperKey.publicKey,
                wrapperKeyId: wrapperKey.id,
            });
            const encryptedResult = await privyEncryption.encrypt();
            // Build alias request.
            const hash = crypto_1.default.createHash('sha256').update(alias, 'utf8').digest();
            const request = {
                ciphertext: Buffer.from(encryptedResult.ciphertext()).toString('base64'),
                hash: hash.toString('hex'),
                alias_wrapper_key_id: Buffer.from(wrapperKey.id).toString('utf8'),
            };
            // Send the encrypted alias to Privy.
            const response = await this._axiosInstance.post(aliasPath(userId), request, undefined);
            // Get response and decrypt.
            const encAliasResponse = response.data;
            return this._decryptAliases(encAliasResponse);
        }
        catch (error) {
            throw (0, errors_1.formatPrivyError)(error);
        }
    }
    /**
     * Delinks a particular user id alias from any other user id's it's linked to. If
     * it is not linked to any other user id, an error is thrown.
     * @param userId A user id that the alias is initially linked to.
     * @param alias The user id to be delinked from the bundle.
     * @returns AliasBundle if everything succeeds. Otherwise an error is thrown.
     */
    async delink(userId, alias) {
        try {
            // Get hash of alias.
            // TODO(dave): Technically just using the hash leaks some info about the alias, in the sense
            // that an informed attacker could confirm whether two user ids / wallet addresses are linked from the url.
            // For the purposes of piloting, we can start with this and change later.
            const hashedAlias = crypto_1.default.createHash('sha256').update(alias, 'utf8').digest();
            await this._axiosInstance.delete(deleteAliasPath(userId, Buffer.from(hashedAlias).toString('hex')), undefined);
            return;
        }
        catch (error) {
            throw (0, errors_1.formatPrivyError)(error);
        }
    }
    /**
     * Reads and decrypts the aliases a given user id is linked to.
     * @param userId Any user id within the alias bundle.
     * @returns AliasBundle if everything succeeds. Otherwise an error is thrown.
     */
    async fetchAliases(userId) {
        try {
            const response = await this._axiosInstance.get(aliasPath(userId), undefined);
            // Get response and decrypt.
            const encAliasResponse = response.data;
            return this._decryptAliases(encAliasResponse);
        }
        catch (error) {
            throw (0, errors_1.formatPrivyError)(error);
        }
    }
    /**
     * Generate a Privy access token for the given data requester.
     * @param requesterId Data requester user ID.
     */
    async createAccessToken(requesterId) {
        const claims = (0, accessToken_1.createAccessTokenClaims)(this._apiKey, requesterId);
        return this._signingFn(claims);
    }
    /**
     * List all fields.
     */
    async listFields() {
        try {
            const response = await this._axiosInstance.get(fieldsPath());
            return response.data;
        }
        catch (error) {
            throw (0, errors_1.formatPrivyError)(error);
        }
    }
    /**
     * Create a field.
     * @param attributes
     * @param attributes.name The field name of which the field id is derived.
     * @param attributes.description Description of the field's purpose.
     * @param attributes.default_access_group The default access group for this field.
     */
    async createField(attributes) {
        try {
            const response = await this._axiosInstance.post(fieldsPath(), attributes);
            return response.data;
        }
        catch (error) {
            throw (0, errors_1.formatPrivyError)(error);
        }
    }
    /**
     * Retrieve a field.
     * @param fieldId Unique alphanumeric identifier for the field.
     */
    async getField(fieldId) {
        try {
            const response = await this._axiosInstance.get(fieldPath(fieldId));
            return response.data;
        }
        catch (error) {
            throw (0, errors_1.formatPrivyError)(error);
        }
    }
    /**
     * Update a field.
     * @param attributes
     * @param attributes.name The field name of which the field id is derived.
     * @param attributes.description Description of the field's purpose.
     * @param attributes.default_access_group The default access group for this field.
     */
    async updateField(fieldId, attributes) {
        try {
            const response = await this._axiosInstance.post(fieldPath(fieldId), attributes);
            return response.data;
        }
        catch (error) {
            throw (0, errors_1.formatPrivyError)(error);
        }
    }
    /**
     * Delete a field.
     * @param fieldId Unique alphanumeric identifier for the field.
     */
    async deleteField(fieldId) {
        try {
            await this._axiosInstance.delete(fieldPath(fieldId));
            return;
        }
        catch (error) {
            throw (0, errors_1.formatPrivyError)(error);
        }
    }
    /**
     * List all roles.
     * Retrieves all the defined roles for this account.
     */
    async listRoles() {
        try {
            const response = await this._axiosInstance.get(rolesPath());
            return response.data;
        }
        catch (error) {
            throw (0, errors_1.formatPrivyError)(error);
        }
    }
    /**
     * Create a role.
     * @param attributes
     * @param attributes.name Unique name for the role.
     * @param attributes.description Arbitrary string attached to the role.
     */
    async createRole(attributes) {
        try {
            const response = await this._axiosInstance.post(rolesPath(), attributes);
            return response.data;
        }
        catch (error) {
            throw (0, errors_1.formatPrivyError)(error);
        }
    }
    /**
     * Retrieve a role.
     * @param roleId Unique alphanumeric identifier for the role.
     */
    async getRole(roleId) {
        try {
            const response = await this._axiosInstance.get(rolePath(roleId));
            return response.data;
        }
        catch (error) {
            throw (0, errors_1.formatPrivyError)(error);
        }
    }
    /**
     * Update a role.
     * Default roles cannot be updated.
     * @param roleId Unique alphanumeric identifier for the role.
     * @param attributes
     * @param attributes.name Unique name for the role.
     * @param attributes.description Arbitrary string attached to the role.
     */
    async updateRole(roleId, attributes) {
        try {
            const response = await this._axiosInstance.post(rolePath(roleId), attributes);
            return response.data;
        }
        catch (error) {
            throw (0, errors_1.formatPrivyError)(error);
        }
    }
    /**
     * Delete a role.
     * Default roles cannot be deleted.
     * @param roleId Unique alphanumeric identifier for the role.
     */
    async deleteRole(roleId) {
        try {
            await this._axiosInstance.delete(rolePath(roleId));
            return;
        }
        catch (error) {
            throw (0, errors_1.formatPrivyError)(error);
        }
    }
    /**
     * List all access groups.
     * Retrieves all the defined access groups for this account.
     */
    async listAccessGroups() {
        try {
            const response = await this._axiosInstance.get(accessGroupsPath());
            return response.data;
        }
        catch (error) {
            throw (0, errors_1.formatPrivyError)(error);
        }
    }
    /**
     * Create an access group.
     * @param attributes
     * @param attributes.name The access group name of which the access group id is derived.
     * @param attributes.description Description of the access group's purpose.
     * @param attributes.read_roles List of role ids that have READ permission in this group.
     * @param attributes.write_roles List of role ids that have WRITE permission in this group.
     */
    async createAccessGroup(attributes) {
        try {
            const response = await this._axiosInstance.post(accessGroupsPath(), attributes);
            return response.data;
        }
        catch (error) {
            throw (0, errors_1.formatPrivyError)(error);
        }
    }
    /**
     * Retrieve an access group.
     * @param accessGroupId The id of the access group.
     */
    async getAccessGroup(accessGroupId) {
        try {
            const response = await this._axiosInstance.get(accessGroupPath(accessGroupId));
            return response.data;
        }
        catch (error) {
            throw (0, errors_1.formatPrivyError)(error);
        }
    }
    /**
     * Update an access group.
     * Default access groups cannot be updated.
     * @param accessGroupId The id of the access group.
     * @param attributes
     * @param attributes.name The access group name of which the access group id is derived.
     * @param attributes.description Description of the access group's purpose.
     * @param attributes.read_roles List of role ids that have READ permission in this group.
     * @param attributes.write_roles List of role ids that have WRITE permission in this group.
     */
    async updateAccessGroup(accessGroupId, attributes) {
        try {
            const response = await this._axiosInstance.post(accessGroupPath(accessGroupId), attributes);
            return response.data;
        }
        catch (error) {
            throw (0, errors_1.formatPrivyError)(error);
        }
    }
    /**
     * Delete an access group
     * Default access groups cannot be deleted.
     * @param accessGroupId The id of the access group.
     */
    async deleteAccessGroup(accessGroupId) {
        try {
            await this._axiosInstance.delete(accessGroupPath(accessGroupId));
            return;
        }
        catch (error) {
            throw (0, errors_1.formatPrivyError)(error);
        }
    }
    /**
     * Get the permissions required for accessing a given user's data.
     * @param userId The id of the user to fetch permissions for.
     * @param fieldIds Optional list of field ids to scope the request to.
     */
    async getUserPermissions(userId, fieldIds) {
        try {
            const response = await this._axiosInstance.get(userPermissionsPath(userId, fieldIds));
            return response.data.data;
        }
        catch (error) {
            throw (0, errors_1.formatPrivyError)(error);
        }
    }
    /**
     * Update the permissions required for accessing a given user's data.
     * @param userId The id of the user to fetch permissions for.
     * @param permissions A list of permissions objects.
     */
    async updateUserPermissions(userId, permissions) {
        try {
            const response = await this._axiosInstance.post(userPermissionsPath(userId), { data: permissions });
            return response.data.data;
        }
        catch (error) {
            throw (0, errors_1.formatPrivyError)(error);
        }
    }
    /**
     * Get all the roles assigned to the requester.
     * @param requesterId The id of the requester.
     */
    async getRequesterRoles(requesterId) {
        try {
            const response = await this._axiosInstance.get(requesterRolesPath(requesterId));
            return response.data.role_ids;
        }
        catch (error) {
            throw (0, errors_1.formatPrivyError)(error);
        }
    }
    /**
     * Get all the requesters assigned to the given role id.
     * @param roleId The id of the role.
     */
    async getRoleRequesters(roleId) {
        try {
            const response = await this._axiosInstance.get(roleRequestersPath(roleId));
            return response.data.requester_ids;
        }
        catch (error) {
            throw (0, errors_1.formatPrivyError)(error);
        }
    }
    /**
     * Assign the given role to a list of requesters.
     * @param roleId The id of the role.
     * @param requesterIds A list of requester ids to assign the role.
     */
    async addRequestersToRole(roleId, requesterIds) {
        try {
            const response = await this._axiosInstance.post(roleRequestersPath(roleId), { requester_ids: requesterIds });
            return response.data.added_requester_ids;
        }
        catch (error) {
            throw (0, errors_1.formatPrivyError)(error);
        }
    }
    /**
     * Remove the requester from the given role.
     * @param roleId The id of the role.
     * @param requesterId The requester to remove from the role.
     */
    async removeRequesterFromRole(roleId, requesterId) {
        try {
            await this._axiosInstance.delete(roleRequesterPath(roleId, requesterId));
            return;
        }
        catch (error) {
            throw (0, errors_1.formatPrivyError)(error);
        }
    }
}
exports.PrivyConfig = PrivyConfig;
//# sourceMappingURL=config.js.map