/// <reference types="node" />
import { BatchOptions, EncryptedUserDataResponseValue, DataKeyUserRequest, DataKeyBatchRequest } from './types';
import { FieldInstance, BatchFieldInstances } from './fieldInstance';
import { PrivyConfig, SigningFn } from './config';
/**
 * The Privy client performs operations against the Privy API.
 *
 * ```typescript
 * import {PrivyClient} from '@privy-io/privy-node';
 * ```
 */
export declare class PrivyClient extends PrivyConfig {
    private api;
    private kms;
    /**
     * Creates a new Privy client.
     * @param apiKey Privy API key.
     * @param apiSecret Privy API secret.
     * @param options Initialization options.
     */
    constructor(apiKey: string, apiSecret: string, options?: {
        /**
         * The URL of the Privy API. Defaults to `https://api.privy.io/v0`.
         */
        apiURL?: string;
        /**
         * The URL of the Privy KMS. Defaults to `https://kms.privy.io/v0`.
         */
        kmsURL?: string;
        /**
         * Time in milliseconds after which to timeout requests to the API and KMS. Defaults to `10000` (10 seconds).
         */
        timeout?: number;
        /**
         * Overrides auth token signing and disables automatic signing key generation.
         * Custom auth public keys can be registered with Privy via the console.
         */
        customSigningFn?: SigningFn;
    });
    /**
     * Get a single field of user data from the Privy API.
     *
     * ```typescript
     * const email = await client.get("0x123", "email");
     * ```
     *
     * @param userId The id of the user this data belongs to.
     * @param fields String field name.
     * @returns A {@link FieldInstance} if the field exists, or `null` otherwise.
     */
    get(userId: string, fields: string): Promise<FieldInstance | null>;
    /**
     * Get multiple fields of user data from the Privy API.
     *
     * ```typescript
     * const [firstName, lastName] = await client.get("0x123", ["first-name", "last-name"]);
     * ```
     *
     * @param userId The id of the user this data belongs to.
     * @param fields Array of string field names.
     * @returns Array of results in the same order as the input. Each result is a {@link FieldInstance} if the field exists or `null` otherwise.
     */
    get(userId: string, fields: string[]): Promise<Array<FieldInstance | null>>;
    /**
     * Get a batch of admin-accessible user data from the Privy API, indexed by user ID.
     *
     * @param fields: String field name or an array of string field names.
     * @param options Optional object containing batch request configuration.
     * @param options.cursor Optional user ID to start from. Returned by previous call to `getBatch`.
     * @param options.limit Optional maximum number of users to return.
     */
    getBatch(fields: string | string[], options?: BatchOptions): Promise<BatchFieldInstances>;
    /**
     * Updates data for a single field for a given user.
     *
     * ```typescript
     * const email = await client.put("0x123", "email", "foo@example.com");
     * ```
     *
     * @param userId The id of the user this data belongs to.
     * @param field String field name.
     * @param value Value to save.
     * @returns {@link FieldInstance} of the updated field.
     */
    put(userId: string, field: string, value: string): Promise<FieldInstance>;
    /**
     * Updates data for multiple fields for a given user.
     *
     * ```typescript
     * const [firstName, lastName] = await client.put("0x123", [
     *   {field: "first-name", value: "Jane"},
     *   {field: "last-name", value: "Doe"},
     * ]);
     * ```
     *
     * @param userId The id of the user this data belongs to.
     * @param fields Array of objects with `field` and `value` keys.
     * @returns Array of {@link FieldInstance}s of the updated fields, in the same order as the input.
     */
    put(userId: string, fields: {
        field: string;
        value: string;
    }[]): Promise<FieldInstance[]>;
    /**
     * Download a file stored under a field.
     *
     * ```typescript
     * const avatar = await client.getFile("0x123", "avatar");
     * download(avatar);
     *
     * function download(field: FieldInstance) {
     *   const data = window.URL.createObjectURL(field.blob());
     *
     *   // Lookup extension by mime type (included on blob)
     *   const ext = getExtensionFromMIMEType(blob.type);
     *   const filename = `${field.integrity_hash}.${ext}`;
     *
     *   // Create a link pointing to the ObjectURL containing the blob.
     *   const link = document.createElement("a");
     *   link.style = "display: none;";
     *   link.href = data;
     *   link.download = filename;
     *   link.click();
     *
     *   // Cleanup
     *   window.URL.revokeObjectURL(data);
     *   link.remove();
     * }
     * ```
     *
     * @param userId The id of the user this file belongs to.
     * @param field The field the file is stored under.
     * @returns A {@link FieldInstance} if the file exists, or `null` otherwise.
     */
    getFile(userId: string, field: string): Promise<FieldInstance | null>;
    /**
     * Upload a file for a given field.
     *
     * ```typescript
     * const onUpdateAvatar = async (avatar: File) => {
     *   try {
     *     await client.putFile("0x123", "avatar", avatar);
     *   } catch (error) {
     *     console.log(error);
     *   }
     * };
     * ```
     *
     * @param userId The id of the user this file belongs to.
     * @param field The field to store the file in.
     * @param blob The plaintext contents of the file in a Blob.
     * @returns {@link FieldInstance} for the uploaded file.
     */
    putFile(userId: string, field: string, plaintext: Buffer, contentType: string): Promise<FieldInstance>;
    /**
     * Lookup a field instance by its integrity hash. This method can be used to verify data in addition to fetching it from Privy. For example, this method will:
     *
     * 1. Lookup data by integrity hash
     * 2. Return the field instance if it exists
     * 3. Re-compute the integrity hash client side. If it is NOT the same as the `integrityHash` argument, this method will throw an error.
     *
     * ```typescript
     * const ssn = await client.put("0x123", "ssn", "123-45-6789");
     * const ssnIntegrityHash = ssn.integrity_hash;
     *
     * // later on...
     * const ssn = await client.getByIntegrityHash(ssnIntegrityHash);
     * ```
     *
     * @param integrityHash Hash used for content addressing.
     * @returns The corresponding {@link FieldInstance} if it exists, or `null` otherwise.
     */
    getByIntegrityHash(integrityHash: string): Promise<FieldInstance | null>;
    private encrypt;
    private decrypt;
    private encryptFile;
    private decryptFile;
    decryptAndVerify(field: EncryptedUserDataResponseValue, ciphertext: Uint8Array, integrityHash: string): Promise<Uint8Array>;
    getWrapperKeys(userId: string, fields: string[], algorithm: string): Promise<{
        id: Uint8Array;
        publicKey: Uint8Array;
        algorithm: string;
    }[]>;
    decryptKeys(request: DataKeyUserRequest): Promise<Uint8Array[]>;
    /**
     * Calls the KMS to decrypt the given data keys.
     * @param request The DataKeyBatchRequest to send to the KMS.
     * @returns 2-D Array of decrypted batch keys ordered by the same ordering of user, field as the
     * request, mapping to the decrypted key if it exists or `null` otherwise.
     */
    decryptBatchKeys(request: DataKeyBatchRequest): Promise<(Uint8Array | null)[][]>;
    /**
     * Decrypts the given encrypted batch data response and returns an array of UserFieldInstances in the
     * same order as the response.
     * @param fieldIDs The field IDs of the fields to decrypt.
     * @param batchDataResponse The response from the API with encrypted data.
     * @returns Array of UserFieldInstances in the same order as the response.
     */
    private decryptBatch;
    /**
     * Sends an email to a given user ID with the subject and HTML specified.
     *
     * Optionally, if you would like to incorporate user data into the email, you
     * may do so using the {@link https://handlebarsjs.com/ Handlebars} templating
     * format. Embed the field IDs corresponding to desired values into the HTML
     * content and update the fields param to include those fields.
     *
     * For example, if you include `fields=["username"]`, you can then use this in
     * your htmlContent like so: `htmlContent="Hello {{username}}, ..."`
     *
     * @param userId User ID
     * @param subject Subject of the email
     * @param htmlContent HTML content to send. If any handlebars content is included,
     *     it will be replaced using the fields provided before sending.
     * @param fields Single field ID or an array of field IDs to dynamically
     *     include in the email using Handlebars. Files, such as images, are not
     *     yet supported.
     *
     * @precondition In order for `sendEmail` to work, a valid destination email
     *     must already be stored for the input user `userId` in a field with the
     *     field ID `email`.
     */
    sendEmail(userId: string, subject: string, htmlContent: string, fields?: string | string[]): Promise<void>;
}
