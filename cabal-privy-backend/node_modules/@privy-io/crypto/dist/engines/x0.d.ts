/**
 * This is only used to encrypt the AES secret key so that
 * the only way to decrypt it is with the RSA private key.
 * The RSA private key is stored in an HSM and is thus never
 * exposed to the Privy server or any clients.
 *
 * The next iteration of Privy's crypto code will be using ECC
 * and thus moving away from the less secure RSA+SHA1.
 */
export declare const WRAPPER_KEY_ALGORITHM = "RSA_2048";
export declare class EncryptionResult {
    /**
     * Returns the ciphertext.
     */
    ciphertext(): Uint8Array;
    /**
     * Returns the wrapper key id.
     */
    wrapperKeyId(): Uint8Array;
    /**
     * Returns the commitment id which is (a sha256 hash).
     */
    commitmentId(): Uint8Array;
}
export interface EncryptConfig {
    wrapperKey: Uint8Array;
    wrapperKeyId: Uint8Array;
}
export declare class Encryption {
    /**
     * Instantiates a new Encryption instance.
     *
     * @param plaintext - The plaintext data to encrypt.
     * @param {EncryptConfig} config - An object to configure encryption.
     *   * wrapperKey - (Uint8Array) The wrapper key (RSA public key in DER format).
     *   * wrapperKeyId - (Uint8Array) The metadata ID of the RSA public key.
     */
    constructor(plaintext: Uint8Array, config: EncryptConfig);
    /**
     * Encrypts the given plaintext data.
     *
     * At a high level, the encryption algorithm is implemented as follows:
     *
     *     1. Generate a secret key (aka, data key) and initialization vector
     *     2. Encrypt (AES-256-GCM) plaintext data using data key
     *     3. Generate and encrypt a nonce used for data integrity checks
     *     4. Encrypt (RSA-OAEP-SHA1) data key with wrapper key (RSA public key)
     *     5. Serialize the following components into a single buffer:
     *         * Privy crypto version (0x0001 in this case)
     *         * wrapper key id
     *         * encrypted data key
     *         * initialization vector for AES-256-GCM
     *         * encrypted data
     *         * encrypted nonce
     *     6. Generate the commitment id (sha256 hash) for (nonce || plaintext)
     *     7. Return an EncryptionResult object
     *
     * @returns a Promise that resolves to an EncryptionResult
     */
    encrypt(): Promise<EncryptionResult>;
}
export declare class DecryptionResult {
    /**
     * Returns the plaintext.
     */
    plaintext(): Uint8Array;
    /**
     * Returns the commitment nonce.
     */
    commitmentNonce(): Uint8Array;
}
export declare class Decryption {
    /**
     * Instantiates a new Decryption instance.
     *
     * @param serialized - The serialized encrypted data to decrypt.
     */
    constructor(serialized: Uint8Array);
    /**
     * Returns the wrapper key id.
     */
    wrapperKeyId(): Uint8Array;
    /**
     * Returns the encrypted data key.
     */
    encryptedDataKey(): Uint8Array;
    /**
     * Decrypts the encrypted data using the given key.
     *
     * @param {Uint8Array} key - The secret key used to encrypt the data.
     * @returns DecryptionResult containing the plaintext data.
     */
    decrypt(key: Uint8Array): Promise<DecryptionResult>;
    /**
     * Performs a data integrity check to verify that the decrypted data matches the given commitment id.
     *
     * @params {DecryptionResult} decryptionResult containing the plaintext data.
     * @param {Uint8Array} commitmentId - Commitment hash used to perform optional data integrity check.
     * @returns True if commitment id matches hash calculated from the decryptionResult, false otherwise.
     */
    verify(decryptionResult: DecryptionResult, commitmentId: Uint8Array): Promise<boolean>;
}
//# sourceMappingURL=x0.d.ts.map