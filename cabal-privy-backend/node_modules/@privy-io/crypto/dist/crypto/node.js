"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Crypto = void 0;
var crypto_1 = __importDefault(require("crypto"));
var buffers_1 = require("../buffers");
var constants_1 = require("./constants");
var AES_256_GCM = 'aes-256-gcm';
var PEM_HEADER = '-----BEGIN PUBLIC KEY-----';
var PEM_FOOTER = '-----END PUBLIC KEY-----';
function derToPEMEncodedString(key) {
    // 1. Convert DER Uint8Array to base64-encoded string.
    var base64 = Buffer.from(key.buffer, key.byteOffset, key.byteLength).toString('base64');
    // 2. Split base64 string into chunks according to PEM format.
    var chunks = base64.match(/.{1,64}/g);
    // 3. Join chunks with newlines.
    var contents = chunks.join('\n');
    // 4. Create key in PEM format
    var pem = "".concat(PEM_HEADER, "\n").concat(contents, "\n").concat(PEM_FOOTER);
    // 5. Return key in PEM format
    return pem;
}
function csprng(byteLength) {
    var buffer = crypto_1.default.randomBytes(byteLength);
    return new Uint8Array(buffer);
}
function aesGCMEncryptionKey() {
    return Promise.resolve(csprng(constants_1.AES_KEY_LENGTH_32_BYTES));
}
function aesGCMEncrypt(pt, iv, key) {
    var cipher = crypto_1.default.createCipheriv(AES_256_GCM, key, iv);
    var encrypted = (0, buffers_1.concatBuffers)(cipher.update(pt), cipher.final());
    var authTag = cipher.getAuthTag();
    return Promise.resolve((0, buffers_1.concatBuffers)(encrypted, authTag));
}
function aesGCMDecrypt(ct, iv, key) {
    var encrypted = ct.slice(0, ct.length - constants_1.AUTH_TAG_LENGTH_16_BYTES);
    var authTag = ct.slice(ct.length - constants_1.AUTH_TAG_LENGTH_16_BYTES, ct.length);
    var decipher = crypto_1.default.createDecipheriv(AES_256_GCM, key, iv);
    decipher.setAuthTag(authTag);
    var decrypted = (0, buffers_1.concatBuffers)(decipher.update(encrypted), decipher.final());
    return Promise.resolve(decrypted);
}
function rsaOAEPEncrypt(pt, key) {
    var encrypted = crypto_1.default.publicEncrypt({
        key: derToPEMEncodedString(key),
        oaepHash: 'sha1',
    }, pt);
    return Promise.resolve(new Uint8Array(encrypted));
}
function sha256(data) {
    var hash = crypto_1.default.createHash('sha256').update(data).digest();
    return Promise.resolve(new Uint8Array(hash));
}
exports.Crypto = {
    csprng: csprng,
    sha256: sha256,
    aesGCMEncrypt: aesGCMEncrypt,
    aesGCMDecrypt: aesGCMDecrypt,
    aesGCMEncryptionKey: aesGCMEncryptionKey,
    rsaOAEPEncrypt: rsaOAEPEncrypt,
};
//# sourceMappingURL=node.js.map